<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>JDU </title>
  <link rel="stylesheet" href="/static/style.css?1710866974.048725" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
</head>

<body>
  

<div class="main">

  <div class="left-menu">


    <a class="brand" href="/">JDU</a>

    <div class="contents">

      <h3><a href="#top">Class Warfare!</a></h3>

      <ul>
        

        <li class="toc-1"><a href="#_what_is_a_class?"><small>1</small>What is a Class?</a></li>

        

        <li class="toc-2"><a href="#_composition"><small>2</small>Composition</a></li>

        

        <li class="toc-3"><a href="#_static_classes"><small>3</small>Static Classes</a></li>

        

        <li class="toc-4"><a href="#_getters_and_setters"><small>4</small>Getters and Setters</a></li>

        

        <li class="toc-5"><a href="#_accessing_all_instances_of_a_class"><small>5</small>Accessing all instances of a class</a></li>

        

        <li class="toc-6"><a href="#_other___magic___methods"><small>6</small>Other `__magic__` methods</a></li>

        

        <li class="toc-6.1"><a href="#___repr__"><small>6.1</small>`__repr__`</a></li>

        

        <li class="toc-6.2"><a href="#_operator_overloading"><small>6.2</small>Operator Overloading</a></li>

        

        <li class="toc-6.3"><a href="#___slots__"><small>6.3</small>__slots__</a></li>

        

        <!-- <li class="divider"></li> -->

        <!--

        <li class="end-part">
          <a href="#references">References</a>
        </li>

        <li class="end-part">
          <a href="#end-note"><small>note</small>End Note</a>
        </li>

        -->
      </ul>

    </div>
  </div>

  <div class="page">
    <h1>Class Warfare!</h1>

    <article class="chapter">

      <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This is a bit of a high-level run-through of "Classes" in python, a bit about object-oriented programming, and just generally a walk through of some cool stuff you can do with them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_class">What is a Class?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A class can be likened to a "template", it&#8217;s a structure which defines what information an instance of that template holds, how it behaves, and how it operates.</p>
</div>
<div class="paragraph">
<p>Classes can "inherit" or be "composed" together to create ever more complex structures of logic and information. We&#8217;ll get to that in a bit but let&#8217;s go over some of the basic bits of a class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Animal:
    def __init__(self, name=None):
        self.name = name</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a really basic class. Like a function, but instead of def we use the class keyword.</p>
</div>
<div class="paragraph">
<p>You will have noticed that funky-lookin' <code><em>init</em></code> method (a method is a function defined on a class).</p>
</div>
<div class="paragraph">
<p>This is called a "constructor", it&#8217;s called automatically by python when you create an instance of a class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_animal = Animal(name="Marmoset")</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we create an instance of our class (known as instantiation), in the background, python exposes the <em>init</em> method in a magic way to make Animal a callable (i.e. it acts like a function).</p>
</div>
<div class="paragraph">
<p>And even though our <em>init</em>() doesn&#8217;t specify a return, python magic makes it so that when you&#8217;re instantiating an instance of a class this way, it returns the newly created instance of the class.</p>
</div>
<div class="paragraph">
<p>So calling Animal(name="Marmoset") is akin to doing something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">def create_animal(name=None):
    new_animal = &lt;a_new_uninitialized_instance_of_the_class_Animal&gt;
    new_animal.__init__(new_animal, name=name)
    return new_animal

my_animal = create_animal(name="Marmoset")</code></pre>
</div>
</div>
<div class="paragraph">
<p>But instead of you having to write out that weird pseudo-code, python does some magic for you so that all you have to do is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_animal = Animal(name="Penguin")</code></pre>
</div>
</div>
<div class="paragraph">
<p>my_animal is now an instance of the type Animal, and we can inspect this using the type() function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">print(type(my_animal))
# &lt;class '__main__.Animal'&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>So what is it that we&#8217;re actually doing in the constructor (i.e. <em>init</em>)? You may have noticed that <em>init</em> accepts an argument self, something we aren&#8217;t passing to it, this is part of the python magic as well. When you call Animal() python is creating the instance of the class, and passing that specific instance to the constructor as the self argument like we showed in the fake create_animal function above.</p>
</div>
<div class="paragraph">
<p>When you implement methods on a class, in general, you&#8217;ll always have self as the first argument in any method signature because python wraps your method in an outer method that passes the class instance itself into your method first.</p>
</div>
<div class="paragraph">
<p>And you CAN implement your own methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Animal:
    def __init__(self, name=None):
        self.name = name

    def make_noise(self):
        print("&lt;silence&gt;")

my_animal = Animal(name="Marmoset")

my_animal.make_noise() # Calling our custom method
# &lt;silence&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our animal doesn&#8217;t have a sound, but we didn&#8217;t give it one, so let&#8217;s add sound to our <em>init</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Animal:
    def __init__(self, name=None, sound=None):
        self.name = name
        self.sound = sound

    def make_noise(self):
        if self.sound:
            print(self.sound)
        else:
            print('&lt;silence&gt;')

my_animal = Animal(name="Cow", sound="Mooo")

my_animal.make_noise()
# Mooo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cool, we added a new property to our class, and we assigned it through the constructor. But we can also change that value after the fact too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_animal.sound = "Squawk"

my_animal.make_sound()
# Squawk</code></pre>
</div>
</div>
<div class="paragraph">
<p>So not only does a class act as a way to encapsulate business logic that has commonality, it also acts as a sort of dict that stores information and data that we can access from within the class (through the self argument) or from outside by accessing the properties using dot-notation (.) directly (my_animal.sound).</p>
</div>
<div class="paragraph">
<p>Now I like my Animal, but I want to add another property called collar_colour, and well, not all animals have collars, only pets really do. However, I don&#8217;t want to have to create a whole new class for "Pets" and have to maintain the same common properties and methods in two places.</p>
</div>
<div class="paragraph">
<p>This is where "sub-classing" comes in. Using sub-classing, a new class, can inherit the properties of a parent class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Pet(Animal): # &lt;- we inherit Animal
    def __init__(self, collar=None, **kwargs):
        super().__init__(self, **kwargs)
        self.collar = collar

my_pet = Pet(name="Dog", sound="Woof", collar="Red")

my_pet.make_sound()
# Woof</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re getting a bit crazy now! Our new class Pet inherits from Animal. So effectively when you create a new instance of Pet you&#8217;re also creating a new instance of Animal. Your new instance of Pet inherits the properties and methods of the Animal class.</p>
</div>
<div class="paragraph">
<p>To save ourselves some typing, we can use the special function super() to get the parent of our current class and call functions on the parent class.</p>
</div>
<div class="paragraph">
<p>In this case <code>super().<em>init</em>(self. **kwargs)</code> we&#8217;re unpacking the other keyword arguments and passing them to the <em>init</em> method of Animal. This saves us having to type out self.name = name again as well as ensuring we trigger any additional logic defined in the Animal classes <em>init</em>.</p>
</div>
<div class="paragraph">
<p>We could go on to create another sub-class, a sub-class of Pet called Dog for specific dog features, and behaviour, and we could go even further and create new classes that inherit from Dog representing individual breeds, customizing and tweaking the behaviour as we go further down the inheritance structure.</p>
</div>
<div class="paragraph">
<p>This, is a style of object-oriented programming (OOP for short). The idea is that you encapsulate common functionality into classes (objects) and inherit and extend those for specific use cases.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_composition">Composition</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Another approach to using classes is Composition. Using classes composed together in order to abstract or simplify code interfaces and logic. Let&#8217;s jump into an example:</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say I have an application, and I need to track the state of some stuff. What I might do is create a new class called ApplicationState.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class ApplicationState:
    def __init__(self):
        pass</code></pre>
</div>
</div>
<div class="paragraph">
<p>I could create sub-classes of the ApplicationState but that runs diagonal to my need, I need a "centralized" point to control things, not a distributed, customized set of functionality spread around, but I don&#8217;t want one big huge monolithic monster class either, that would be hard to maintain. That&#8217;s when we reach for Composition. So lets say that my application is a library manager, keeping track of books I own. So the first thing we need is a class representing a book.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Book:
    def __init__(self, title=None, author=None):
        self.title = title
        self.author = author</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cool, so we could then just add a property books to our application state that&#8217;s a list containing a bunch of Book instances right?</p>
</div>
<div class="paragraph">
<p>Sure, but we can go even further than that, lets create a Books class instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Books:
    def __init__(self)
        self.books = []</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we create this new class Books, and one of it&#8217;s internal properties is an empty list of Book.</p>
</div>
<div class="paragraph">
<p>But how do we get the books "in there"? Well, we implement a new method called load_books and we call it from our <em>init</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Books:
    def __init__(self):
        self.books = []
        self.load_books()

    def load_books(self):
        """ Loads up books from our library.json file"""
        raw_books = []
        with open("library.json", "r") as f:
            raw_books = json.load(f)

        self.books = [Book(**x) for x in raw_books)</code></pre>
</div>
</div>
<div class="paragraph">
<p>What about if we want to save our library? Let&#8217;s implement a to_dict function on our Book class to help us out with converting individual books back to dicts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Book:

    ...

    def to_dict(self):
        return {
            "title": self.title,
            "author": self.author,
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s add a save_books method to our Books class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Books:

    ...

    def save_books(self):
        """ flush our library to disk """
        raw_books = [x.to_dict() for x in self.books]

        with open("library.json", "w") as f:
            json.dump(raw_books)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ok so now we can create an instance of our Books class and do stuff with it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">my_library = Books()

for book in my_library.books:
    print(book.title, book.author)

my_library.save_books()
# writes to library.json</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because we&#8217;ve wrapped our list of Book up into an encapsulating class (we composed it) we can implement methods on Books to help us manage that list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Books:

    ...

    def find_by_author(self, author_name):
        """ Find all books by a specific author """
        return [x for x in self.books if x.author == author_name]

    def delete_book(self, title_to_delete):
        """ Delete a book from our library """
        self.books = [x for x in self.books if x.title != title_to_delete]
        self.save_books() # call our method to persist the changes

    def has_book(self. title_to_find):
        """ check if we already have a book """
        return len([x for x in self.books if x.title == title_to_find]) &gt; 0

    def update_author(self, title_to_edit, new_author):
        """ Update a titles author name """
        for book in self.books:
            if book.title == title_to_edit:
                book.author = new_author

        self.save_books()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Books class lets us centralize re-usable functionality within the class to make it easier to manage, maintain and access.</p>
</div>
<div class="paragraph">
<p>Now instead of our code being littered with variations of the same logic all over the place in different areas of our code-base, it&#8217;s neatly set up in one place, next to the data it operates on, and if we need to update it, we only have to look at where we defined the class.</p>
</div>
<div class="paragraph">
<p>Now in the context of our ApplicationState we can actually wrap our Books class inside of our ApplicationState and add some additional stuff for our application that we need that might be functionally different.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class ApplicationState:
    def __init__(self):
        self.library = Books() # Instantiate our library
        self.app_title = "My Library"
        self.book_search = BookSearch() # Some other class we've encapsulated data and logic into</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now instead of having to pass around individual instances of these specific classes, we just pass around our ApplicationState instance and access its internals through dot-notation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">app_state = ApplicationState()
app_state.library.save_books()

jeffs_books = app_state.library.find_by_author("Jeff Uren")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also abstract those lower-level functions, or wrap more code around them to help us handle specific events for instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class ApplicationState:

    ...

    def on_shutdown(self):
        """ if the application shuts down make sure we save our library before we lose it """
        self.library.save_books()
        sys.exit(1)

    def do_we_have_book(self, title):
        return self.library.has_book(title)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now I can have a really simple top-level program that wraps all this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">if __name__ = "__main__":
    app_state = ApplicationState()

    author_name = input("Find Books By Author: ")
    found_books = app_state.library.find_by_author(author_name)

    for book in found_books:
        print(book.title, book.author)</code></pre>
</div>
</div>
<div class="paragraph">
<p>My main application / script doesn&#8217;t have to be cluttered with all the lower down, complicated logic and programming.</p>
</div>
<div class="paragraph">
<p>This is Composition.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_static_classes">Static Classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes you want to wrap up a bunch of functionality together and access it in a convenient way, but you don&#8217;t actually need an instance of class, you just want to group some common functionality together thematically.</p>
</div>
<div class="paragraph">
<p>You can define classes which you never actually create an instance of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Utils:
    @staticmethod
    def remove_jeff(some_str):
        return some_str.replace("Jeff", "")

    @staticmethod
    def add_jeff(some_str):
        return some_str + " Jeff"

Utils.remove_jeff("This string has Jeff in it")
Utils.add_jeff("This string needs someone in it!")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how we don&#8217;t have an <em>init</em> and in our methods we defined, we don&#8217;t have self as the first argument? This class, although you can still instantiate it using Utils(), it&#8217;s not a requirement that you do so in order to use its methods. This is an easy way to group common functionality together in a class to help you organize things.</p>
</div>
<div class="paragraph">
<p>The @staticmethod decorator tells python that the method should be available through Utils.&lt;method_name&gt; without having to instantiate an instance of the class and blocks it from accessing internals of the class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_getters_and_setters">Getters and Setters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you create a class with properties in it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class MyClass:
    def __init__(self, some_prop):
        self.some_prop = some_prop</code></pre>
</div>
</div>
<div class="paragraph">
<p>some_prop is now editable from outside and inside of the class. But what if you don&#8217;t want that, or you want to control how it&#8217;s set / retrieved? That&#8217;s when we get into getters and setters. These allow you to layer over top of the properties on a class, or hide properties of a class from the user so they can&#8217;t make changes to them without you allowing it.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s say we have a property we want to control, or that when it changes, some other logic should fire as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Person:
    def __init__(self, age)
        self._age = age # See how we're using `_` here to "hide" the property
        self.birth_year = 2022 - age

    @property
    def age(self):
        print("getting their age")
        return self._age

    @setter.age
    def age(self, new_age):
        print("Updating age")
        self.birth_year = 2022 - new_age
        self._age = new_age

jeff = Person(39)

print(jeff.birth_year)
# 1983

jeff.age = 87
# Updating age
print(jeff.birth_year)
# 1935</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we do jeff.age = 87 we&#8217;re not editing the _age property underneath directly, python has let us overload the = operator to mean age(87) and mapped it to our @setter.age annotated function.</p>
</div>
<div class="paragraph">
<p>Likewise when we try to get jeff.age we&#8217;re not accessing a property directly, python is doing some magic to allow you to treat a method on the class instance, as if it were a property, when in reality jeff.age is actually calling jeff.age().</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_accessing_all_instances_of_a_class">Accessing all instances of a class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Want to see something weird?</p>
</div>
<div class="paragraph">
<p>Properties declared under the class heading are common to all instances of a given class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Person:
    all_the_people = []

    def __init__(self):
        self.all_the_people.append(self)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Looks weird doesn&#8217;t it, but it means that no matter where you are in your code, you can do something relative cool, you can access all instances of a class from any given instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">list_of_peeps = [
    Person(),
    Person(),
]

person_dict = {
    {"1": Person()},
}

some_other_person = Person()

for person in some_other_person.all_the_people:
    print(person)

# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>So you can for instance, have a constant in your class that&#8217;s used in a computation in one of the methods of your class instances. And when you update that property for a given instance of the class, it will update for all instances of the class throughout your code that are reachable.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_magic_methods">Other <code><em>magic</em></code> methods</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_repr"><code><em>repr</em></code></h3>
<div class="paragraph">
<p>When you do print(some_var) ever wonder where the output of print comes from, who decides what it looks like, and when you print a class instance, why is it that horrible &lt;<em>main</em>.ClassName object at xxxxx&gt; message that tells you nothing about the thing you&#8217;re printing?</p>
</div>
<div class="paragraph">
<p>That&#8217;s where <em>repr</em> comes in, you can use it to customize the output of print() when an instance of your class is passed to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Person:
    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        return f"&lt;Person name={self.name}&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;re overriding the default implementation of <em>repr</em> on our class here, we just have to return a string from the method, which is what print will output to the console, log or wherever you&#8217;re sending this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">p = Person(name="Bob")

print(p)
# &lt;Person name=Bob&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operator_overloading">Operator Overloading</h3>
<div class="paragraph">
<p>You can actually overload (i.e. overwrite) what a class instance does when you use it with a comparison operator (i.e. =, &gt;=, &#8656;, etc&#8230;&#8203;) so that you can have custom comparison logic for your class instances.</p>
</div>
<div class="paragraph">
<p>I&#8217;ll give you an example using our earlier Book class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Book:
    def __init__(self, title=None, Author=None):
        self.author = author
        self.title = title</code></pre>
</div>
</div>
<div class="paragraph">
<p>There&#8217;s our book class, but let&#8217;s say we have two instances of the Book class for two different books:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">book_1 = Book(title="Hitchhikers Guide to the Galaxy", author="Douglas Adams")

book_2 = Book(title="Zen and the Art of motorcycle maintenance", author="Robert M. Persig")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s say we want to check if these two books are the same book, how would you go about that?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">same_book = False

if book_1.title == book_2.title and book_1.author == book_2.author:
    same_book = True</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s not particularly intuitive, and we don&#8217;t really want to have to write that over and over all over our code. But if we could do the below, that would be much cleaner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">same_book = False

if book_1 == book_2:
    same_book = True</code></pre>
</div>
</div>
<div class="paragraph">
<p>But in reality that&#8217;s checking if the two instance classes are the same instance, not that that the properties inside the instance are equal. But we can fix that!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Book:

    ...

    def __eq__(self, other):
        if self.title == other.title and self.author == other.author:
            return True
        else:
            return False</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we&#8217;ve overloaded <em>eq</em>, we can now compare two books using the == operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">same_book = book_1 == book_2</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do this with all sorts of different operators, for instance &gt; is <em>gt</em> and &gt;= is <em>gte</em>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add one more, but this time to the Books class that holds our list of Books:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Books:
    def __init__(self)
        self.books = []
        self.load_books()

    ...

    def __iter__(self):
        for book in self.books:
            yield book

    def append(self, new_book):
        self.books.append(new_book)
        self.save_books()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ve implemented one overloaded operator called <em>iter</em>, and we&#8217;ve added a new method called append(). This allows us to make instances of the Books class act a bit like a List.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">library = Books()

# we don't have to reach into library.books property anymore!
for book in library:
    print(book)

new_book = Book(title="Hitchhikers Guide to the Galaxy", author="Douglas Adams")

library.append(new_book)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This simplifies your interactions with instances of the class, and makes it so you can use it without having to know the deep internals of the class itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="_slots"><em>slots</em></h3>
<div class="paragraph">
<p>Classes have a special property named <em>slots</em> that can help your code run more efficiently under the hood and enforce some constraints on your classes.</p>
</div>
<div class="paragraph">
<p>The <em>slots</em> parameter allows you to set a list of properties which should be allowed on your class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class Book:
    __slots__ = ["title", "author"]

    def __init__(self, title=None, author=None):
        self.title = title
        self.author = author</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifying <em>slots</em> is more memory efficient, as the class instantiation logic knows that it only needs to reserve enough space in memory for two properties. This is important because properties for individual instances of a class are actually stored in a python dict behind the scenes if you don&#8217;t use <em>slots</em>, and dicts reserve a larger amount of space in memory for themselves in order to allow you to add more data to it over time without shifting things around in memory.</p>
</div>
<div class="paragraph">
<p>When a property of a class is stored inside of a <em>slots</em> instead of a dict, retrieving the value from the slot is actually much faster than if it was stored in the backend in a dict.</p>
</div>
<div class="paragraph">
<p>On a small scale this might not seem that big of a deal, but if you&#8217;re playing with a large data-set where each record is loaded into an instance of your class, the performance gain and reduction in memory usage can be pretty dramatic, even over using a plain old dict and no class at all.</p>
</div>
<div class="paragraph">
<p>Classes in Data Engineering</p>
</div>
<div class="paragraph">
<p>This is all well and good, but what use are classes in Data Engineering?</p>
</div>
<div class="paragraph">
<p>There&#8217;s loads of use cases. You can use classes to represent individual data items, you can use classes to wrap an iterator on a file of records, where it loads up each file and does some processing on it before returning the file to your larger code. You can use a class to encapsulate and simplify interacting with an API.</p>
</div>
<div class="paragraph">
<p>Our airflow instance uses KubernetesPodOperator which is a class that abstract away a whole lot of complexity, so that you can spin up tasks in a kubernetes pod without having to worry about all those complicated gubbins.</p>
</div>
<div class="paragraph">
<p>You can use classes to represent different types of records within a large non-standard record set, or you can use it to group special properties together to help you realize some complex functionality or logic.</p>
</div>
<div class="paragraph">
<p>For example, you can implement a new PublicationId type which wraps around the various type of publications IDs (DOI, pmc, pmcid, dimensions id, rf_id, etc&#8230;&#8203;) and implements complex <em>eq</em> logic to decide if two publications are one and the same.</p>
</div>
<div class="paragraph">
<p>Hopefully this ones been useful for ya&#8217;ll!</p>
</div>
</div>
</div>
</div>


    </article>


    <footer>
      Handcrafted by Jeff Uren — <a href="https://github.com/jdu/jdu.github.io/blob/master/LICENSE"
        target="_blank">&copy; 2024</a>
    </footer>
  </div>

</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<!-- and it's easy to individually load additional languages -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>

<script>hljs.highlightAll();</script>


</body>

</html>