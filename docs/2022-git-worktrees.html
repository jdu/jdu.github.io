<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>git Worktrees</title>
    <link rel="stylesheet" href="static/css/tufte.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <article>
      <h1>git Worktrees</h1>
      <p class="subh2">Jeff Uren â˜… 2024</p>

      <section>
        <p>
          You may or may not have noticed that some of the people in the DataOps
          team work with <literal>git</literal> in a slightly different way than
          you would normally expect people to.
        </p>
        <p>
          If you hadn&#8217;t noticed, you&#8217;re in for a bit of a
          roller-coaster ride into an oft-unused feature of git that makes
          jumping between branches and different contexts a lot easier.
        </p>
      </section>
      <section xml:id="_a_little_background">
        <h2>A Little Background</h2>
        <p>
          The reason we work the way that I&#8217;m going to describe further
          down is because we do <emphasis role="strong">alot</emphasis> of
          context switching. When I say alot I mean alot. We jump between
          different pipelines, bugfixes and tasks more or less constantly
          throughout a day because some of our code takes time to run before we
          really see the fruits of our labours.
        </p>
        <p>
          Normal branching in git requires that you check in your code whenever
          you need to swap to another branch so that you&#8217;re not carrying
          changes between different sets of branches by accident. It&#8217;s
          really annoying when you forget to check in a file and swap branches
          and then suddenly you&#8217;ve got a change from another set of work
          sitting in your new, totally unrelated branch.
        </p>
      </section>
      <section xml:id="_how_dataops_and_i_use_worktrees">
        <h2>How DataOps (and I) use worktrees</h2>
        <p>First we create a barebones folder to hold our project:</p>
        <screen>$ mdir my_project</screen>
        <p>
          We then clone the "bare" repository into a directory called
          <literal>.bare</literal>
        </p>
        <screen linenumbering="unnumbered"
          >$ git clone --bare git@github.com/wellcometrust/wt-data .bare</screen
        >
        <p>
          What this does is clone down the internal git repo database but not
          the artifacts themselves. So this is all the information about the
          different branches, commits, merges, etc&#8230;&#8203; that exist in
          the repo.
        </p>
        <p>
          Once we have that in place we need to set a config file at the root of
          our <literal>my_project</literal> folder to tell it to look in the
          <literal>.bare</literal> folder for the git repos information.
        </p>
        <screen linenumbering="unnumbered"
          >$ echo "gitdir: ./.bare" &gt; .git</screen
        >
        <p>
          Now we can run the command <literal>git status</literal> and our
          top-level folder will act like it&#8217;s the git repo that we want to
          work with&#8230;&#8203; sort of.
        </p>
        <p>We need to create our first worktree first.</p>
        <screen linenumbering="unnumbered">$ git worktree add main</screen>
        <p>
          What this will do is checkout the <literal>main</literal> branch into
          a folder called <literal>main</literal> under our
          <literal>my_project</literal> folder.
        </p>
        <p>
          That probably doesn&#8217;t seem all that special to be honest. But
          this is where the magic kicks in.
        </p>
        <p>
          We can now have multiple top-level directories in our root folder
          representing branches. So we can go ahead and add another worktree:
        </p>
        <screen linenumbering="unnumbered"
          >$ git worktree add some-new-feature</screen
        >
        <p>
          and we&#8217;ll now have two branch-based directories in our root
          directory.
        </p>
        <screen linenumbering="unnumbered"
          >my_project/ .bare/ main/ some-new-feature/</screen
        >
        <p>
          Not rather than swapping / checking out branches, stashing changes to
          swap between branches, or doing unnecessary commits just to work
          around these things, we can simply change directories and even work on
          two sets of changes concurrently.
        </p>
        <p>
          Once we&#8217;re done, and we&#8217;ve pushed our branch to the
          remote:
        </p>
        <screen linenumbering="unnumbered"
          >$ cd some-new-feature $ git push origin some-new-feature</screen
        >
        <p>
          We can go ahead and remove the worktree from the root by using the
          command:
        </p>
        <screen linenumbering="unnumbered"
          >$ git worktree remove some-new-feature</screen
        >
        <p>
          Drop into main and pull down the changes once we&#8217;ve merged them
          in:
        </p>
        <screen linenumbering="unnumbered"
          >$ cd main &amp;&amp; git pull origin main</screen
        >
        <p>
          And then checkout a new worktree for whatever we&#8217;re working on
          next:
        </p>
        <screen linenumbering="unnumbered"
          >$ git worktree add another-new-feature</screen
        >
      </section>
    </article>
  </body>
</html>
