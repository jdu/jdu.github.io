= Fear the Rebase

One of the aspects of `git` (and version control in general) that people seem to have the most anxiety about, is rebasing. In engineering circles, the term "rebase" can create an immediate sense of dread at a level befitting a horror film. That dread increases linearly with the length of time it's been since you either last rebased, or initially branched away from the safety of the `main`.

== It's Work

// Illustration of branch lagging behind main
.Illustration of branch lagging behind main, drastically

One of the reasons that people espouse making smaller, incremental change and -- keeping new branches specific and constrained -- is to avoid the situation above. While you have been toiling away, life has carried on in the `main` branch, without you, and you are suddenly faced with a situation where you need all of that "new" work available in your special branch you've been hunkered down in for the last of couple weeks or even months.

Let's be honest, we have a tendency to lump things together, and even though most of your branches are pointed, here and there, we all have a tendency to go off the rails a bit. I mean it's just one line of code that you notice could have been a tad bit more performant in that other file over there.

But this is one of the reasons we _have_ `git`, to smooth over these rough patches and to reduce the burden on the developer these situations create. NOtice I said "reduce", we can't eliminate it completely, but trust me when I say that handling some rebase conflicts is a lot better than what we used to have to do.

== What Dark Art is This?

So what does rebase actually do? And when should you rebase? There are a couple of main reasons you might want to use a rebase:

- It's been a long while since you create your branch, and it will be awhile before it's ready to be merged into them `main` or `master` branch, but in the meantime you need other peoples changes that have been merged in since your branch was cut.
- You know there will be problems when it comes time to merge your branch, and you want to smooth out those problems well ahead of time.
- You want your code to be pinned to a different, specific commit in `main` (for instance a commit for a specific release version your code targets) to test your changes against different, older versions of your code-base.

There are really, any number of reasons that you might want to do it to be honest, but what is actually happening during a rebase? How can we dispel the sense of dread we get at the mere mention of it?

== Rest ye weary time traveller

A lot of people like to think of rebasing as "rewriting the history of their branch".

.Image of rebase before and after

We're effectively telling `git` to transport us to another time and place, along with all of our baggage. And just as if you were suddenly flying 30 years into the future, in real life, the further into the future you are flung, the higher the probability that there is going to need to be some adjustments made in order to "fit in".

In `git` parlance, we call these "conflicts". We don't really have a proper time machine in the `git` world, but what we do have is the ability to rapidly move you through the intervening years (or commits) and make judgment calls on some easier adjustments. But if it gets too hard, `git` will ask you to intervene and help it to figure out what to do.

`git`'s version control is based around objects, a given project can have any number of objects (mostly files,) and for a series of commits in the history of a branch, a lot of those files can stay pretty well the same. The "work" arises really, when a change to a file in your branch, doesn't get along with a change to a file in the branch you're rebasing on.