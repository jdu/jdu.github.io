<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>No Title - JDU</title>
    <link rel="stylesheet" href="../static/css/tufte.css" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <article>
      <h1>No Title</h1>
      <section><?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Class Warfare!</title>
<date>2026-01-05</date>
</info>
<simpara>This is a bit of a high-level run-through of "Classes" in python, a bit about object-oriented programming, and just generally a walk through of some cool stuff you can do with them.</simpara>
<section xml:id="_what_is_a_class">
<title>What is a Class?</title>
<simpara>A class can be likened to a "template", it&#8217;s a structure which defines what information an instance of that template holds, how it behaves, and how it operates.</simpara>
<simpara>Classes can "inherit" or be "composed" together to create ever more complex structures of logic and information. We&#8217;ll get to that in a bit but let&#8217;s go over some of the basic bits of a class.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Animal:
    def __init__(self, name=None):
        self.name = name</programlisting>
<simpara>This is a really basic class. Like a function, but instead of def we use the class keyword.</simpara>
<simpara>You will have noticed that funky-lookin' <literal><emphasis>init</emphasis></literal> method (a method is a function defined on a class).</simpara>
<simpara>This is called a "constructor", it&#8217;s called automatically by python when you create an instance of a class.</simpara>
<programlisting language="python" linenumbering="unnumbered">my_animal = Animal(name="Marmoset")</programlisting>
<simpara>When we create an instance of our class (known as instantiation), in the background, python exposes the <emphasis>init</emphasis> method in a magic way to make Animal a callable (i.e. it acts like a function).</simpara>
<simpara>And even though our <emphasis>init</emphasis>() doesn&#8217;t specify a return, python magic makes it so that when you&#8217;re instantiating an instance of a class this way, it returns the newly created instance of the class.</simpara>
<simpara>So calling Animal(name="Marmoset") is akin to doing something like this:</simpara>
<programlisting language="python" linenumbering="unnumbered">def create_animal(name=None):
    new_animal = &lt;a_new_uninitialized_instance_of_the_class_Animal&gt;
    new_animal.__init__(new_animal, name=name)
    return new_animal

my_animal = create_animal(name="Marmoset")</programlisting>
<simpara>But instead of you having to write out that weird pseudo-code, python does some magic for you so that all you have to do is:</simpara>
<programlisting language="python" linenumbering="unnumbered">my_animal = Animal(name="Penguin")</programlisting>
<simpara>my_animal is now an instance of the type Animal, and we can inspect this using the type() function:</simpara>
<programlisting language="python" linenumbering="unnumbered">print(type(my_animal))
# &lt;class '__main__.Animal'&gt;</programlisting>
<simpara>So what is it that we&#8217;re actually doing in the constructor (i.e. <emphasis>init</emphasis>)? You may have noticed that <emphasis>init</emphasis> accepts an argument self, something we aren&#8217;t passing to it, this is part of the python magic as well. When you call Animal() python is creating the instance of the class, and passing that specific instance to the constructor as the self argument like we showed in the fake create_animal function above.</simpara>
<simpara>When you implement methods on a class, in general, you&#8217;ll always have self as the first argument in any method signature because python wraps your method in an outer method that passes the class instance itself into your method first.</simpara>
<simpara>And you CAN implement your own methods:</simpara>
<programlisting language="python" linenumbering="unnumbered">class Animal:
    def __init__(self, name=None):
        self.name = name

    def make_noise(self):
        print("&lt;silence&gt;")

my_animal = Animal(name="Marmoset")

my_animal.make_noise() # Calling our custom method
# &lt;silence&gt;</programlisting>
<simpara>Our animal doesn&#8217;t have a sound, but we didn&#8217;t give it one, so let&#8217;s add sound to our <emphasis>init</emphasis>.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Animal:
    def __init__(self, name=None, sound=None):
        self.name = name
        self.sound = sound

    def make_noise(self):
        if self.sound:
            print(self.sound)
        else:
            print('&lt;silence&gt;')

my_animal = Animal(name="Cow", sound="Mooo")

my_animal.make_noise()
# Mooo</programlisting>
<simpara>Cool, we added a new property to our class, and we assigned it through the constructor. But we can also change that value after the fact too:</simpara>
<programlisting language="python" linenumbering="unnumbered">my_animal.sound = "Squawk"

my_animal.make_sound()
# Squawk</programlisting>
<simpara>So not only does a class act as a way to encapsulate business logic that has commonality, it also acts as a sort of dict that stores information and data that we can access from within the class (through the self argument) or from outside by accessing the properties using dot-notation (.) directly (my_animal.sound).</simpara>
<simpara>Now I like my Animal, but I want to add another property called collar_colour, and well, not all animals have collars, only pets really do. However, I don&#8217;t want to have to create a whole new class for "Pets" and have to maintain the same common properties and methods in two places.</simpara>
<simpara>This is where "sub-classing" comes in. Using sub-classing, a new class, can inherit the properties of a parent class.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Pet(Animal): # &lt;- we inherit Animal
    def __init__(self, collar=None, **kwargs):
        super().__init__(self, **kwargs)
        self.collar = collar

my_pet = Pet(name="Dog", sound="Woof", collar="Red")

my_pet.make_sound()
# Woof</programlisting>
<simpara>We&#8217;re getting a bit crazy now! Our new class Pet inherits from Animal. So effectively when you create a new instance of Pet you&#8217;re also creating a new instance of Animal. Your new instance of Pet inherits the properties and methods of the Animal class.</simpara>
<simpara>To save ourselves some typing, we can use the special function super() to get the parent of our current class and call functions on the parent class.</simpara>
<simpara>In this case <literal>super().<emphasis>init</emphasis>(self. **kwargs)</literal> we&#8217;re unpacking the other keyword arguments and passing them to the <emphasis>init</emphasis> method of Animal. This saves us having to type out self.name = name again as well as ensuring we trigger any additional logic defined in the Animal classes <emphasis>init</emphasis>.</simpara>
<simpara>We could go on to create another sub-class, a sub-class of Pet called Dog for specific dog features, and behaviour, and we could go even further and create new classes that inherit from Dog representing individual breeds, customizing and tweaking the behaviour as we go further down the inheritance structure.</simpara>
<simpara>This, is a style of object-oriented programming (OOP for short). The idea is that you encapsulate common functionality into classes (objects) and inherit and extend those for specific use cases.</simpara>
</section>
<section xml:id="_composition">
<title>Composition</title>
<simpara>Another approach to using classes is Composition. Using classes composed together in order to abstract or simplify code interfaces and logic. Let&#8217;s jump into an example:</simpara>
<simpara>Let&#8217;s say I have an application, and I need to track the state of some stuff. What I might do is create a new class called ApplicationState.</simpara>
<programlisting language="python" linenumbering="unnumbered">class ApplicationState:
    def __init__(self):
        pass</programlisting>
<simpara>I could create sub-classes of the ApplicationState but that runs diagonal to my need, I need a "centralized" point to control things, not a distributed, customized set of functionality spread around, but I don&#8217;t want one big huge monolithic monster class either, that would be hard to maintain. That&#8217;s when we reach for Composition. So lets say that my application is a library manager, keeping track of books I own. So the first thing we need is a class representing a book.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Book:
    def __init__(self, title=None, author=None):
        self.title = title
        self.author = author</programlisting>
<simpara>Cool, so we could then just add a property books to our application state that&#8217;s a list containing a bunch of Book instances right?</simpara>
<simpara>Sure, but we can go even further than that, lets create a Books class instead.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Books:
    def __init__(self)
        self.books = []</programlisting>
<simpara>So we create this new class Books, and one of it&#8217;s internal properties is an empty list of Book.</simpara>
<simpara>But how do we get the books "in there"? Well, we implement a new method called load_books and we call it from our <emphasis>init</emphasis>.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Books:
    def __init__(self):
        self.books = []
        self.load_books()

    def load_books(self):
        """ Loads up books from our library.json file"""
        raw_books = []
        with open("library.json", "r") as f:
            raw_books = json.load(f)

        self.books = [Book(**x) for x in raw_books)</programlisting>
<simpara>What about if we want to save our library? Let&#8217;s implement a to_dict function on our Book class to help us out with converting individual books back to dicts.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Book:

    ...

    def to_dict(self):
        return {
            "title": self.title,
            "author": self.author,
        }</programlisting>
<simpara>Now let&#8217;s add a save_books method to our Books class:</simpara>
<programlisting language="python" linenumbering="unnumbered">class Books:

    ...

    def save_books(self):
        """ flush our library to disk """
        raw_books = [x.to_dict() for x in self.books]

        with open("library.json", "w") as f:
            json.dump(raw_books)</programlisting>
<simpara>Ok so now we can create an instance of our Books class and do stuff with it.</simpara>
<programlisting language="python" linenumbering="unnumbered">my_library = Books()

for book in my_library.books:
    print(book.title, book.author)

my_library.save_books()
# writes to library.json</programlisting>
<simpara>Because we&#8217;ve wrapped our list of Book up into an encapsulating class (we composed it) we can implement methods on Books to help us manage that list.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Books:

    ...

    def find_by_author(self, author_name):
        """ Find all books by a specific author """
        return [x for x in self.books if x.author == author_name]

    def delete_book(self, title_to_delete):
        """ Delete a book from our library """
        self.books = [x for x in self.books if x.title != title_to_delete]
        self.save_books() # call our method to persist the changes

    def has_book(self. title_to_find):
        """ check if we already have a book """
        return len([x for x in self.books if x.title == title_to_find]) &gt; 0

    def update_author(self, title_to_edit, new_author):
        """ Update a titles author name """
        for book in self.books:
            if book.title == title_to_edit:
                book.author = new_author

        self.save_books()</programlisting>
<simpara>The Books class lets us centralize re-usable functionality within the class to make it easier to manage, maintain and access.</simpara>
<simpara>Now instead of our code being littered with variations of the same logic all over the place in different areas of our code-base, it&#8217;s neatly set up in one place, next to the data it operates on, and if we need to update it, we only have to look at where we defined the class.</simpara>
<simpara>Now in the context of our ApplicationState we can actually wrap our Books class inside of our ApplicationState and add some additional stuff for our application that we need that might be functionally different.</simpara>
<programlisting language="python" linenumbering="unnumbered">class ApplicationState:
    def __init__(self):
        self.library = Books() # Instantiate our library
        self.app_title = "My Library"
        self.book_search = BookSearch() # Some other class we've encapsulated data and logic into</programlisting>
<simpara>Now instead of having to pass around individual instances of these specific classes, we just pass around our ApplicationState instance and access its internals through dot-notation.</simpara>
<programlisting language="python" linenumbering="unnumbered">app_state = ApplicationState()
app_state.library.save_books()

jeffs_books = app_state.library.find_by_author("Jeff Uren")</programlisting>
<simpara>We can also abstract those lower-level functions, or wrap more code around them to help us handle specific events for instance:</simpara>
<programlisting language="python" linenumbering="unnumbered">class ApplicationState:

    ...

    def on_shutdown(self):
        """ if the application shuts down make sure we save our library before we lose it """
        self.library.save_books()
        sys.exit(1)

    def do_we_have_book(self, title):
        return self.library.has_book(title)</programlisting>
<simpara>So now I can have a really simple top-level program that wraps all this:</simpara>
<programlisting language="python" linenumbering="unnumbered">if __name__ = "__main__":
    app_state = ApplicationState()

    author_name = input("Find Books By Author: ")
    found_books = app_state.library.find_by_author(author_name)

    for book in found_books:
        print(book.title, book.author)</programlisting>
<simpara>My main application / script doesn&#8217;t have to be cluttered with all the lower down, complicated logic and programming.</simpara>
<simpara>This is Composition.</simpara>
</section>
<section xml:id="_static_classes">
<title>Static Classes</title>
<simpara>Sometimes you want to wrap up a bunch of functionality together and access it in a convenient way, but you don&#8217;t actually need an instance of class, you just want to group some common functionality together thematically.</simpara>
<simpara>You can define classes which you never actually create an instance of:</simpara>
<programlisting language="python" linenumbering="unnumbered">class Utils:
    @staticmethod
    def remove_jeff(some_str):
        return some_str.replace("Jeff", "")

    @staticmethod
    def add_jeff(some_str):
        return some_str + " Jeff"

Utils.remove_jeff("This string has Jeff in it")
Utils.add_jeff("This string needs someone in it!")</programlisting>
<simpara>Notice how we don&#8217;t have an <emphasis>init</emphasis> and in our methods we defined, we don&#8217;t have self as the first argument? This class, although you can still instantiate it using Utils(), it&#8217;s not a requirement that you do so in order to use its methods. This is an easy way to group common functionality together in a class to help you organize things.</simpara>
<simpara>The @staticmethod decorator tells python that the method should be available through Utils.&lt;method_name&gt; without having to instantiate an instance of the class and blocks it from accessing internals of the class.</simpara>
</section>
<section xml:id="_getters_and_setters">
<title>Getters and Setters</title>
<simpara>When you create a class with properties in it:</simpara>
<programlisting language="python" linenumbering="unnumbered">class MyClass:
    def __init__(self, some_prop):
        self.some_prop = some_prop</programlisting>
<simpara>some_prop is now editable from outside and inside of the class. But what if you don&#8217;t want that, or you want to control how it&#8217;s set / retrieved? That&#8217;s when we get into getters and setters. These allow you to layer over top of the properties on a class, or hide properties of a class from the user so they can&#8217;t make changes to them without you allowing it.</simpara>
<simpara>Let&#8217;s say we have a property we want to control, or that when it changes, some other logic should fire as well.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Person:
    def __init__(self, age)
        self._age = age # See how we're using `_` here to "hide" the property
        self.birth_year = 2022 - age

    @property
    def age(self):
        print("getting their age")
        return self._age

    @setter.age
    def age(self, new_age):
        print("Updating age")
        self.birth_year = 2022 - new_age
        self._age = new_age

jeff = Person(39)

print(jeff.birth_year)
# 1983

jeff.age = 87
# Updating age
print(jeff.birth_year)
# 1935</programlisting>
<simpara>When we do jeff.age = 87 we&#8217;re not editing the _age property underneath directly, python has let us overload the = operator to mean age(87) and mapped it to our @setter.age annotated function.</simpara>
<simpara>Likewise when we try to get jeff.age we&#8217;re not accessing a property directly, python is doing some magic to allow you to treat a method on the class instance, as if it were a property, when in reality jeff.age is actually calling jeff.age().</simpara>
</section>
<section xml:id="_accessing_all_instances_of_a_class">
<title>Accessing all instances of a class</title>
<simpara>Want to see something weird?</simpara>
<simpara>Properties declared under the class heading are common to all instances of a given class.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Person:
    all_the_people = []

    def __init__(self):
        self.all_the_people.append(self)</programlisting>
<simpara>Looks weird doesn&#8217;t it, but it means that no matter where you are in your code, you can do something relative cool, you can access all instances of a class from any given instance.</simpara>
<programlisting language="python" linenumbering="unnumbered">list_of_peeps = [
    Person(),
    Person(),
]

person_dict = {
    {"1": Person()},
}

some_other_person = Person()

for person in some_other_person.all_the_people:
    print(person)

# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;
# &lt;__main__.Person object at xxxxxxx&gt;</programlisting>
<simpara>So you can for instance, have a constant in your class that&#8217;s used in a computation in one of the methods of your class instances. And when you update that property for a given instance of the class, it will update for all instances of the class throughout your code that are reachable.</simpara>
</section>
<section xml:id="_other_magic_methods">
<title>Other <literal><emphasis>magic</emphasis></literal> methods</title>
<section xml:id="_repr">
<title><literal><emphasis>repr</emphasis></literal></title>
<simpara>When you do print(some_var) ever wonder where the output of print comes from, who decides what it looks like, and when you print a class instance, why is it that horrible &lt;<emphasis>main</emphasis>.ClassName object at xxxxx&gt; message that tells you nothing about the thing you&#8217;re printing?</simpara>
<simpara>That&#8217;s where <emphasis>repr</emphasis> comes in, you can use it to customize the output of print() when an instance of your class is passed to it.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Person:
    def __init__(self, name=None):
        self.name = name

    def __repr__(self):
        return f"&lt;Person name={self.name}&gt;"</programlisting>
<simpara>We&#8217;re overriding the default implementation of <emphasis>repr</emphasis> on our class here, we just have to return a string from the method, which is what print will output to the console, log or wherever you&#8217;re sending this.</simpara>
<programlisting language="python" linenumbering="unnumbered">p = Person(name="Bob")

print(p)
# &lt;Person name=Bob&gt;</programlisting>
</section>
<section xml:id="_operator_overloading">
<title>Operator Overloading</title>
<simpara>You can actually overload (i.e. overwrite) what a class instance does when you use it with a comparison operator (i.e. =, &gt;=, &#8656;, etc&#8230;&#8203;) so that you can have custom comparison logic for your class instances.</simpara>
<simpara>I&#8217;ll give you an example using our earlier Book class.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Book:
    def __init__(self, title=None, Author=None):
        self.author = author
        self.title = title</programlisting>
<simpara>There&#8217;s our book class, but let&#8217;s say we have two instances of the Book class for two different books:</simpara>
<programlisting language="python" linenumbering="unnumbered">book_1 = Book(title="Hitchhikers Guide to the Galaxy", author="Douglas Adams")

book_2 = Book(title="Zen and the Art of motorcycle maintenance", author="Robert M. Persig")</programlisting>
<simpara>Now let&#8217;s say we want to check if these two books are the same book, how would you go about that?</simpara>
<programlisting language="python" linenumbering="unnumbered">same_book = False

if book_1.title == book_2.title and book_1.author == book_2.author:
    same_book = True</programlisting>
<simpara>That&#8217;s not particularly intuitive, and we don&#8217;t really want to have to write that over and over all over our code. But if we could do the below, that would be much cleaner:</simpara>
<programlisting language="python" linenumbering="unnumbered">same_book = False

if book_1 == book_2:
    same_book = True</programlisting>
<simpara>But in reality that&#8217;s checking if the two instance classes are the same instance, not that that the properties inside the instance are equal. But we can fix that!</simpara>
<programlisting language="python" linenumbering="unnumbered">class Book:

    ...

    def __eq__(self, other):
        if self.title == other.title and self.author == other.author:
            return True
        else:
            return False</programlisting>
<simpara>Now that we&#8217;ve overloaded <emphasis>eq</emphasis>, we can now compare two books using the == operator:</simpara>
<programlisting language="python" linenumbering="unnumbered">same_book = book_1 == book_2</programlisting>
<simpara>You can do this with all sorts of different operators, for instance &gt; is <emphasis>gt</emphasis> and &gt;= is <emphasis>gte</emphasis>.</simpara>
<simpara>Let&#8217;s add one more, but this time to the Books class that holds our list of Books:</simpara>
<programlisting language="python" linenumbering="unnumbered">class Books:
    def __init__(self)
        self.books = []
        self.load_books()

    ...

    def __iter__(self):
        for book in self.books:
            yield book

    def append(self, new_book):
        self.books.append(new_book)
        self.save_books()</programlisting>
<simpara>We&#8217;ve implemented one overloaded operator called <emphasis>iter</emphasis>, and we&#8217;ve added a new method called append(). This allows us to make instances of the Books class act a bit like a List.</simpara>
<programlisting language="python" linenumbering="unnumbered">library = Books()

# we don't have to reach into library.books property anymore!
for book in library:
    print(book)

new_book = Book(title="Hitchhikers Guide to the Galaxy", author="Douglas Adams")

library.append(new_book)</programlisting>
<simpara>This simplifies your interactions with instances of the class, and makes it so you can use it without having to know the deep internals of the class itself.</simpara>
</section>
<section xml:id="_slots">
<title><emphasis>slots</emphasis></title>
<simpara>Classes have a special property named <emphasis>slots</emphasis> that can help your code run more efficiently under the hood and enforce some constraints on your classes.</simpara>
<simpara>The <emphasis>slots</emphasis> parameter allows you to set a list of properties which should be allowed on your class.</simpara>
<programlisting language="python" linenumbering="unnumbered">class Book:
    __slots__ = ["title", "author"]

    def __init__(self, title=None, author=None):
        self.title = title
        self.author = author</programlisting>
<simpara>Specifying <emphasis>slots</emphasis> is more memory efficient, as the class instantiation logic knows that it only needs to reserve enough space in memory for two properties. This is important because properties for individual instances of a class are actually stored in a python dict behind the scenes if you don&#8217;t use <emphasis>slots</emphasis>, and dicts reserve a larger amount of space in memory for themselves in order to allow you to add more data to it over time without shifting things around in memory.</simpara>
<simpara>When a property of a class is stored inside of a <emphasis>slots</emphasis> instead of a dict, retrieving the value from the slot is actually much faster than if it was stored in the backend in a dict.</simpara>
<simpara>On a small scale this might not seem that big of a deal, but if you&#8217;re playing with a large data-set where each record is loaded into an instance of your class, the performance gain and reduction in memory usage can be pretty dramatic, even over using a plain old dict and no class at all.</simpara>
</section>
</section>
<section xml:id="_classes_in_data_engineering">
<title>Classes in Data Engineering</title>
<simpara>This is all well and good, but what use are classes in Data Engineering?</simpara>
<simpara>There&#8217;s loads of use cases. You can use classes to represent individual data items, you can use classes to wrap an iterator on a file of records, where it loads up each file and does some processing on it before returning the file to your larger code. You can use a class to encapsulate and simplify interacting with an API.</simpara>
<simpara>Our airflow instance uses KubernetesPodOperator which is a class that abstract away a whole lot of complexity, so that you can spin up tasks in a kubernetes pod without having to worry about all those complicated gubbins.</simpara>
<simpara>You can use classes to represent different types of records within a large non-standard record set, or you can use it to group special properties together to help you realize some complex functionality or logic.</simpara>
<simpara>For example, you can implement a new PublicationId type which wraps around the various type of publications IDs (DOI, pmc, pmcid, dimensions id, rf_id, etc&#8230;&#8203;) and implements complex <emphasis>eq</emphasis> logic to decide if two publications are one and the same.</simpara>
<simpara>Hopefully this ones been useful for ya&#8217;ll!</simpara>
</section>
</article>
</section>
    </article>
  </body>
</html>